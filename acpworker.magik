_package sw

def_slotted_exemplar(:acpworker,
	{
		{:name, _unset }
	},
	{:user_acp}
)
$

acpworker.define_shared_variable(:protocols, equality_property_list.new_with("get_all", :|get_all()|), :public)
acpworker.define_shared_constant(:success_code, 0, :public)
acpworker.define_shared_constant(:default_delimiter, "|", :public)

_method acpworker.new(name, exe_path)
	>> _clone.init(name, exe_path)
_endmethod

_private _method acpworker.init(name, exe)
	_self.init_copy()
	.name << name
	.command << {write_string(exe)}
	.program_ident << name
	.minimum_protocol << 0
	.maximum_protocol << 1
	print(.command)
	>> _self
_endmethod

_method acpworker.select_protocol()
	_return 0
_endmethod

_method acpworker.register_protocol(protocol_name, method_name)
	_self.protocols[protocol_name] << method_name
_endmethod

_method acpworker.send_error_message(message)
	_self.put_unsigned_byte(1)
	_self.put_chars(message)
	_return 
_endmethod

_method acpworker.send_success_status()
	_self.put_unsigned_byte(_self.success_code)
_endmethod

_method acpworker.start()
	_protect
		_self.lock()
		_loop
			_local protocol_name << _self.get_chars()
			_if protocol_name = "server_fail" _then _leave _endif
			_if protocol_name = "server_stop" _then _leave _endif
			
			_local method_name << _self.protocols[protocol_name]
			_if method_name _is _unset 
			_then
				write("Magik acpworker: ", "Unknown protocol: ", protocol_name)
				_self.send_error_message(write_string("Magik acpworker: ", "Unknown protocol"))
				_self.get_chars()
				_self.get_chars()
				_continue
			_endif
			_self.perform(method_name)
		_endloop
	_protection
		_self.stop()
	_endprotect 
_endmethod

_method acpworker.stop()
	write("acpworker stop process")
	_self.send_success_status()
	_self.put_chars("acpworker process finished")
	_self.flush()
	_self.close(_true)
	_self.unlock()
_endmethod

_method acpworker.get_all()
	_local dataset_name << _self.get_chars()
	_local collection_name << _self.get_chars()
	_local ds << gis_program_manager.databases[dataset_name.as_symbol()]

	# verifica a existencia do dataset pedido
	_if ds _is _unset
	_then
		_self.send_error_message(write_string("The Dataset ", dataset_name, " does not exists"))
		_return
	_endif

	# verifica a existencia da collection informada
	_local collection << ds.collections[collection_name.as_symbol()]
	_if collection _is _unset
	_then
		_self.send_error_message(write_string("The Collection ", collection_name, " does not exists"))
		_return
	_endif

	# envia o resultado positivo
	_self.send_success_status()

	_local fields << rope.new()
	_for f _over collection.all_fields.fast_elements()
	_loop
		fields.add(f.name)
	_endloop

	# envia a quantidade de objetos a serem enviados
	_self.put_unsigned_int(collection.size)
	_self.put_unsigned_int(fields.size)

	_local i << 0
	_local j << 0
	_for record _over collection.fast_elements()
	_loop @records
		i << i + 1
		j << 0
		_for f _over fields.fast_elements()
		_loop @fields
			j << j + 1
			_self.put_chars(write_string(f))
			_self.put_chars(write_string(record.perform(f)))
			_self.flush()
		_endloop
	_endloop
	_self.flush()
_endmethod

_global acpw_snapshot << _unset
_global acpw_thread << _unset

_global acpw_start << _proc(name, exe)
	_global acpw_thread, acpw_snapshot
	acpw_thread << _proc()
		_import name, exe
		_global acpw_snapshot
		acpw_snapshot << acpworker.new(name, exe)
		acpw_snapshot.start()
	_endproc.fork_at(light_thread.vm_priority - 1)
_endproc 

_global acpw_stop << _proc()
	_global acpw_snapshot
	acpw_snapshot.stop()
_endproc

# load_file("C:\Users\ahpv\Documents\Scripts\acp\acpworker.magik")
# acpw_start("w1", "C:\Users\ahpv\Documents\Scripts\acp\server\server.exe")
# acpw_stop()